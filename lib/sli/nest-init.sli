/*
 *  nest-init.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEST Kernel 2 initialisation
%%
%% (C) 2000-2006 The NEST Initiative
%%
%%  Authors Marc-Oliver Gewaltig <marc-oliver.gewaltig@honda-ri.de>
%%          Markus Diesmann <diesmann@fz-juelich.de>
%%          Jochen Martin Eppler <eppler@fz-juelich.de>
%%

M_DEBUG (nest-init.sli) (Initializing SLI support for NEST Kernel.) message
% see nestmodule.cpp

% Add NEST example directory to search-path
statusdict /prgdocdir get (/examples)                  join addpath
statusdict /prgdocdir get (/examples/FacetsBenchmarks) join addpath

/test {
  statusdict/prgdatadir :: (/testsuite/do_tests.sh ) join
  statusdict/prefix :: (/bin/nest) join
  join system ; ;
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% add new functions to trie if it exists, else create new
/SetStatus dup lookup not
{
  trie
} if
[/integertype /dictionarytype] /SetStatus_id load addtotrie
[/connectiontype /dictionarytype] /SetStatus_CD load addtotrie
def

% add new functions to trie if it exists, else create new
/GetStatus dup lookup not
{
  trie
} if
[/integertype] /GetStatus_i load addtotrie
[/connectiontype] /GetStatus_C load addtotrie
[/arraytype] /GetStatus_a load addtotrie
def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% These variants of get access network elements represented by
% a node_id like dictionaries. In particular, if a node_id returns a dictionary,
% get can be used to access the contents of the nested objects.
% 071108, Diesmann
%
/get [/integertype /literaltype] {exch GetStatus exch get} def
/get [/integertype /arraytype] {exch GetStatus exch get_d_a} def

% Same as above for connections
% 100922, Diesmann
/get [/connectiontype /literaltype] {exch GetStatus exch get} def
/get [/connectiontype /arraytype] {exch GetStatus exch get_d_a} def

% The following version allows extraction of a node ID from a NodeCollection
/get [/nodecollectiontype /integertype] { get_g_i } def

% This version gets all values from all nodes. The same as GetStatus, but
% concatenates into a single dictionary.
/get [/nodecollectiontype]
{
  GetStatus
  /status_dict << >> def

  size 1 neq
  { % If not a single value NodeCollection. We have a list of dictionaries.

    % The first thing we do is set the keys in the dictionary based on the
    % first node ID in the NodeCollection, and set the corresponding value in an
    % array.
    dup First {status_dict rollu 1 arraystore put_d} forall

    status_dict keys /ks Set

    % Then, we put the values for the rest of the NodeCollection in the right
    % place in the dictionary.
    /counter 1 def
    Rest
    {
      dup
      {
        /v Set
        /k Set
        % Check if we have a composite NodeCollection by checking if k is part
        % of dict keys.
        ks k MemberQ
        {
          % If primitive, add value to dictionary array
          status_dict k get [v] join /val_array Set
        }
        {
          % If composite, set values for previous node IDs to None, and add value.
          [counter] /None LayoutArray [v] join /val_array Set
          ks [k] join /ks Set
        } ifelse

        % Add value array to status dictionary.
        status_dict k val_array put_d
      } forall

      % If we have a composite nc and there have been values for previous node IDs
      % that is not part of this particular dictionary, we must set a None
      % value for this value.
      keys /dict_keys Set
      ks
      {
        /k Set
        dict_keys k MemberQ not
        {
          status_dict k get [/None] join /val_array Set
          status_dict k val_array put_d
        } if
      } forall

      counter 1 add /counter Set
    } forall

    status_dict
  }
  {
    0 get
  } ifelse
} def

% Get parameter value of all node IDs in NodeCollection
/get [/nodecollectiontype /literaltype]
{
  /value Set
  /nodecollection Set

  nodecollection size 1 eq
  { % if size == 1
    nodecollection GetStatus 0 get value get
  }
  { % if size > 1
    nodecollection GetStatus { value get } Map
  } ifelse
} def

% Get parameter values of NodeCollection from an array of parameters
/get [/nodecollectiontype /arraytype]
{
  exch
  dup size 1 eq not{ /get /InvalidNodeCollectionError raiseerror }if
  0 get_g_i GetStatus exch get_d_a
} def

% Get metadata values of NodeCollection
/GetMetadata [/nodecollectiontype]
  /GetMetadata_g load
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Slicing of NodeCollections with Take
% Since n Take means take first n elements, while [n] Take means return
%      n-th element, we need to be a bit careful, handling the letter case
%      here at the SLI level and mapping the former to the two-element case
% Note that Take indexes from 1, with -1 the last element
/Take [/nodecollectiontype /integertype]
 {
   << >> begin
     /n Set
     /c Set
     n 0 geq
     {
       [ 1 n ]
     }
     {
       n neg c size gt { c n /Take /RangeError raiseerror } if

       c size dup n add 1 add exch
       2 arraystore
     }
     ifelse
     c
     exch
     Take
   end
}
def

/Take [/nodecollectiontype /arraytype]
{
  << >> begin
  /slice Set
  /coll Set

  % Because Take expects arguments with one-based indexing, while Take_g_a expects
  % arguments with zero-based indexing, we need to adjust arguments before calling Take_g_a.
  slice length 1 eq
  {
    slice 0 get dup 2 arraystore /slice Set
  } if

  slice arrayload
  2 eq
  {
    1 /step Set
  }
  {
    /step Set
  } ifelse

  % We assume that we have two or three elements now.
  % Have to adjust slice to zero-indexing.
  /stp Set
  /strt Set

  % With one-based indexing, 0 is not a valid index.
  strt 0 eq
  { % strt == 0
    /Take /RangeError raiseerror
  } if

  % For positive start values, start is adjusted one down for zero-based indexing.
  % The stop value goes from inclusive to exclusive, so positive stop values do not have to be adjusted.
  strt 0 gt
  { % strt > 0
    % adjust to zero-indexing
    strt 1 sub /strt Set
  } if

  % Negative one-based start values are converted to positive zero-based start values.
  strt 0 lt
  { % strt < 0
    strt coll size add /strt Set
  } if

  % Negative one-based stop values are converted to positive zero-based stop values.
  % Because we go from inclusive to exclusive stop value, stop is adjusted one up.
  stp -1 leq
  {
    stp coll size add 1 add /stp Set
  } if

  strt stp step 3 arraystore
  coll exch
  Take_g_a

  end
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/* BeginDocumentation
   Name: LocalOnly - Get only local elements of a NodeCollection.

   Synopsis:
   nodecollection    LocalOnly --> local_nodecollection

   Parameters:
   nodecollection          - NodeCollection in which to find local elements
   local_nodecollection    - NodeCollection with only local elements

   Description:
   This function gets only the local elements in a NodeCollection.
   The resulting elements are returned in a new NodeCollection. If
   there are no local elements, an empty NodeCollection is returned.

   Author: Håkon Mørk
   FirstVersion: November 2017
*/
/LocalOnly [/nodecollectiontype]
{
   << >> begin
     /nc Set
     Rank nc 0 get NumProcesses mod sub NumProcesses add NumProcesses mod 1 add
     dup nc size leq
     {
       nc size NumProcesses 3 arraystore nc exch Take
     }
     {
       pop
       [] cvnodecollection
     } ifelse
   end
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Return array containing only those node IDs for which procedure returns true
%
% Note:
% Returns array so that we can return an empty array if no node matches.
/Select [/nodecollectiontype /proceduretype]
{
  /predicate Set
  mark exch
  {
    dup
    predicate not
    {
      pop
    }
    if
  }
  forall
  counttomark
  arraystore
  exch pop
  currentdict /predicate undef
} bind def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Min and Max for NodeCollections
%

/Min trie
[/nodecollectiontype] { 0 get } addtotrie
[/anytype] /Min load addtotrie
def

/Max trie
[/nodecollectiontype] { dup size 1 sub get } addtotrie
[/anytype] /Max load addtotrie
def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Parameterization


/mul [/parametertype /parametertype]
  /mul_P_P load
def

/div [/parametertype /parametertype]
  /div_P_P load
def

/add [/parametertype /parametertype]
  /add_P_P load
def

/sub [/parametertype /parametertype]
  /sub_P_P load
def

/compare [/parametertype /parametertype /dictionarytype]
  /compare_P_P_D load
def

/conditional [/parametertype /parametertype /parametertype]
  /conditional_P_P_P load
def

/min [/parametertype /doubletype]
  /min_P_d load
def

/max [/parametertype /doubletype]
  /max_P_d load
def

/redraw [/parametertype /doubletype /doubletype]
  /redraw_P_d_d load
def

/exp [/parametertype]
  /exp_P load
def

/sin [/parametertype]
  /sin_P load
def

/cos [/parametertype]
  /cos_P load
def

/pow [/parametertype /doubletype]
  /pow_P_d load
def

/dimension2d [/parametertype /parametertype]
  /dimension2d_P_P load
def

/dimension3d [/parametertype /parametertype /parametertype]
  /dimension3d_P_P_P load
def

/CreateParameter trie
[/dictionarytype] /CreateParameter_D load addtotrie
[/doubletype] /CreateParameter_D load addtotrie
def

/GetValue [/parametertype]
  /GetValue_P load
def

/ParameterIsSpatial [/parametertype]
  /IsSpatial_P load
def

/Apply [/parametertype /dictionarytype]
  /Apply_P_D load
def

/Apply [/parametertype /nodecollectiontype]
  /Apply_P_g load
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/Simulate trie
[/integertype] {cvd Simulate} addtotrie
[/doubletype]  /Simulate_d load addtotrie
def

/Run trie
[/integertype] {cvd Run} addtotrie
[/doubletype]  /Run_d load addtotrie
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% oosupport.sli already defines conversions for dict
/cvdict [/connectiontype]
 /cvdict_C load
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/** @BeginDocumentation
   Name: cvnodecollection - Create a container of node IDs.

   Synopsis:
   list_of_node_ids          cvnodecollection -> nodecollection
   first_node_id    last_node_id cvnodecollection -> nodecollection

   Parameters:
   list_of_node_ids    - an array or intvector of node IDs, or a nodecollection
   first_node_id       - an integer definig the first node ID of the range
   last_node_id        - an integer definig the last node ID of the range

   Description:
   This function creates a nodecollection object, which is a unified
   representation for multiple node IDs of neurons or devices. To
   save memory in the case of contiguous ranges of node IDs, it is
   possible to just use the first and last index of the range to
   initialize the nodecollection.

   Author: Jochen Martin Eppler
   FirstVersion: April 2014

   SeeAlso: cv_iv, Connect
*/

/cvnodecollection trie
  [/integertype /integertype] /cvnodecollection_i_i load addtotrie
  [/arraytype]                /cvnodecollection_ia  load addtotrie
  [/intvectortype]            /cvnodecollection_iv  load addtotrie
  [/nodecollectiontype]        {}                        addtotrie
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% add conversion from NodeCollection
/cva [/nodecollectiontype]
  /cva_g load
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/NodeCollectionQ trie
  [/nodecollectiontype] true addtotrie
  [/anytype] false addtotrie
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% convert to list of node_id-modelid pairs
/cva_node_id_mid trie def
/cva_node_id_mid [/nodecollectiontype]
{
 << >> begin
  dup
  :beginiterator_g /iter Set
  :enditerator_g /enditer Set

  mark
  {
    iter :getnodeidmodelid_q
    iter :next_q
    enditer :lt_q_q not { exit } if
  }
  loop
  counttomark
  arraystore
  exch pop

  end
}
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% join for NodeCollections
/join [/nodecollectiontype /nodecollectiontype]
  /join_g_g load
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% forall, forallindexed and Map for node collections --- brutal implementations

/forall [/nodecollectiontype /proceduretype]
{
  /func Set
  dup
  :beginiterator_g /iter Set
  :enditerator_g /enditer Set

  {
    iter :getnodeid_q
    func
    iter :next_q
    enditer :lt_q_q not { exit } if
  }
  loop

  % Delete local variables; we do not use a local dictionary
  % here in case func should change variables.
  currentdict /func undef
  currentdict /iter undef
  currentdict /enditer undef

} bind def

/forallindexed [/nodecollectiontype /proceduretype]
{
  /func Set
  dup
  :beginiterator_g /iter Set
  :enditerator_g /enditer Set

  /:n 0 def
  {
    iter :getnodeid_q
    :n
    func
    iter :next_q
    /:n :n 1 add def
    enditer :lt_q_q not { exit } if
  }
  loop

  % Delete local variables; we do not use a local dictionary
  % here in case func should change variables.
  currentdict /func undef
  currentdict /iter undef
  currentdict /enditer undef
  currentdict /:n undef

} bind def

/Map [/nodecollectiontype /proceduretype]
{
  << >> begin
  /func Set
  dup
  :beginiterator_g /iter Set
  :enditerator_g /enditer Set

  mark
  {
    iter :getnodeid_q
    func
    iter :next_q
    enditer :lt_q_q not { exit } if
  }
  loop
  counttomark
  arraystore
  exch pop

  end
} bind def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% NodeCollection membership

/InCollection [/nodecollectiontype /integertype]
  /MemberQ_g_i load
def

/Find [/nodecollectiontype /integertype]
  /Find_g_i load
def

/eq [/nodecollectiontype /nodecollectiontype] /eq_g load def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% typeinit.sli already defines size functions for other types
/size [/nodecollectiontype]
  /size_g load
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% GetStatus / SetStatus for NodeCollection

/GetStatus [/nodecollectiontype]
  /GetStatus_g load
def

/SetStatus [/nodecollectiontype /dictionarytype]
{
  1 pick ValidQ_g not { /SetStatus /InvalidNodeCollectionError raiseerror } if
  exch { 1 pick SetStatus_id } forall
  pop % dictionary
}
def

/SetStatus [/nodecollectiontype /arraytype]
{
  1 pick ValidQ_g not { /SetStatus /InvalidNodeCollectionError raiseerror } if
  << >> begin
  /params Set
  /nc Set

  params length nc size neq
  {
    nc params /SetStatus /IncompatibleLengths raiseerror
  }
  if

  nc :beginiterator_g /iter Set
  nc :enditerator_g /enditer Set

  params
  {
    iter :getnodeid_q exch
    SetStatus_id
    iter :next_q pop
  }
  forall

  end
}
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/GetResolution {
    GetKernelStatus /resolution get
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/** @BeginDocumentation
   Name: GetNodes - Return IDs of all nodes that fulfill the conditions given in
                    the dictionary, or all nodes if no dictionary given. Returns
                    only mpi local nodes if local_bool is true.
   Synopsis:
     <<dict>> local_bool GetNodes -> NodeCollection
   Parameters:
     <<dict>>   - Dictionary of selection properties
     local_bool - Bool indicating whether or not we want only local nodes.
   Returns:
     NodeCollection  - NodeCollection with the node IDs of all nodes or all mpi
                      local nodes if local_bool is true.
   Description:
   This function recursively traverses all nodes and returns the global
   ids of all nodes in increasing order of node_id if local_bool is false, if not, it
   returns local nodes. If a dictionary is provided, only those nodes which fulfill
   the given criteria are returned.
*/

/GetNodes trie
  [/dictionarytype /booltype] { GetNodes_D_b } bind addtotrie
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     Create and variants
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/Create_l
{
  1 Create_l_i
} def

/Create_l_D
{
  1 exch Create_l_i_D
} def

/Create_l_i_D
{
  << >> begin

    /params Set
    /n Set
    /model Set

    model GetDefaults /element_type get /recorder neq
    {
      % For stimulators and neurons, we store the old parameters that
      % are given in params, then set params as model defaults, create
      % the nodes and restore the old parameters.

      model GetDefaults /oldparams Set
      /tmp << >> def

      % get implicitly checks if params contains 'illegal' keys
      params keys { /key Set tmp key oldparams key get put } forall
      tmp /oldparams Set

      model params SetDefaults
      model n Create_l_i
      model oldparams SetDefaults
    }
    {
      % For recorders, we can't use the more efficient method
      % above. The reason for this is that recording backend
      % properties might differ between backends and the backend might
      % be changed away from the default during the call to Create,
      % resulting in lookup errors.

      model n Create_l_i
      dup params SetStatus
    } ifelse

  end % local namespace
} def


/Create trie
  [/literaltype                             ] /Create_l     load addtotrie
  [/literaltype /integertype                ] /Create_l_i   load addtotrie
  [/literaltype              /dictionarytype] /Create_l_D   load addtotrie
  [/literaltype /integertype /dictionarytype] /Create_l_i_D load addtotrie
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     Model handling
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/CopyModel_l_l
{
  << >> CopyModel_l_l_D
} bind def

/CopyModel trie
  [/literaltype /literaltype                ] /CopyModel_l_l   load addtotrie
  [/literaltype /literaltype /dictionarytype] /CopyModel_l_l_D load addtotrie
def

/SetDefaults
  [/literaltype /dictionarytype] /SetDefaults_l_D load
def

/GetDefaults
  [/literaltype] /GetDefaults_l load
def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/** @BeginDocumentation
   Name: ShowDefaults - Show the default parameters of a model.

   Synopsis:
   /modelname ShowDefaults -> -

   Description:
   ShowDefaults retrieves the dictionary of default values from the
   specified model and displays it, using info. ShowDefaults is
   equivalent to the sequence "GetDefaults info"

   SeeAlso: GetDefaults, info
*/

/ShowDefaults
{
  GetDefaults info
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     Connect and its variants
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


/** @BeginDocumentation
   Name: Connect - Establish a connection between two nodes or lists of nodes.

   Synopsis:
   sources targets                        Connect
   sources targets weight delay           Connect
   sources targets weight delay syn_model Connect
   sources targets conn_rule              Connect
   sources targets conn_spec              Connect
   sources targets conn_rule syn_model    Connect
   sources targets conn_spec syn_model    Connect
   sources targets conn_rule syn_spec     Connect
   sources targets conn_spec syn_spec     Connect

   Parameters:
   sources    nodecollection  - the node IDs of the sources
   targets    nodecollection  - the node IDs of the targets
   weight     double          - the weight of the connection
   delay      double          - the delay of the connection
   conn_rule  literal         - the name of the connection rule
   conn_spec  dict            - dictionary with connectivity specification (see Options)
   syn_model  literal         - the name of the synapse model
   syn_spec   dict            - dictionary with synapse model specification (see Options)

   Options:
   /conn_spec - dictionary with connectivity specification, must at least contain /rule

                The following options may be given for all connection rules;
                not all rules support all options and many rules add rule-specific options.

                allow_autapses  bool  - allow self-connections (default: true)
                allow_multapses bool  - allow multiple connections between pairs
                                        of neurons (default: true)
                symmetric       bool  - also create connection in opposite direction to
                                      obtain symmetric connections (default: false)

   /syn_spec  - dictionary with synapse specification, must at least contain /model

   Description:
   Connects sources to targets according to the given connectivity
   specification conn_spec. Some connection rules impose requirements.
   E.g. /one_to_one requires that sources and targets have the same
   number of elements. Others may have additional parameters,
   e.g. connection probability /p for /pairwise_binomial.

   The variants with only literal arguments /conn_rule or /syn_model
   are shorthand for the corresponding calls with connectivity or
   synapse specification dictionaries as explained in the Options
   section.  The literals are expanded to << /rule /conn_rule >> and
   << /synapse_model /syn_model >>, respectively.

   Parameters for connectivity rules must have fixed values.

   Parameters for synapses may be fixed single values, arrays or random deviate
   specifications.

   A list of available connection rules can be obtained from the
   kernel status dictionary by inspecting the key /connection_rules.

   SeeAlso: cvnodecollection, GetOptions

   Author: Hannah Bos, Hans Ekkehard Plesser, Jochen Martin Eppler

   FirstVersion: January 2014
*/

%%% Options for Connect

/Connect <<
  /conn_spec << /rule /all_to_all >>
  /syn_spec << /synapse_model /static_synapse >>
>> Options


%%% Helper functions for Connect

% Expects a synapse or connection specification dictionary on the
% stack and extends it by the defaults from Connect's Options for
% all keys from the given spec in the Options for Connect that are
% missing in the given dictionary.
% Usage: dict /lit, where lit is the name of the spec in the Options
/:Connect_complete_dict {
    << >> begin
    /optname Set
    /Connect optname GetOption keys {
    	dup /key Set
	exch dup 3 2 roll known not {
	  dup key /Connect optname GetOption key get put
        } if
    } forall
    end
} def


%%% Variants of Connect

/Connect trie

  % We create the type trie for the different variants using a loop
  [/arraytype /intvectortype /nodecollectiontype] {
      /node_idlisttype Set

      % Variant: sources targets Connect
      % Connect nodes from two sets of node IDs using the default rule and
      % synapse model
      [node_idlisttype node_idlisttype] {
          cvnodecollection exch  % convert targets to nodecollection
          cvnodecollection exch  % convert sources to nodecollection
          /Connect /conn_spec GetOption  % use default conn_spec
          /Connect /syn_spec GetOption   % use default syn_spec
          Connect_g_g_D_D
      } bind addtotrie

      % Variant: sources targets weight delay Connect
      % Connect nodes from two sets of node IDs using the default rule and
      % synapse model but with the given weight and delay
      [node_idlisttype node_idlisttype /doubletype /doubletype] {
          mark 3 1 roll         % put a mark before weight and delay
          /weight 3 1 roll      % add a label for the weight
          /delay 2 1 roll       % add a label for the delay
          >>                    % create the syn_spec dictionary
          /syn_spec :Connect_complete_dict    % fill in missing defaults
          /Connect /conn_spec GetOption exch  % use default conn_spec
          4 2 roll              % bring sources and targets to top
          cvnodecollection exch  % convert targets to nodecollection
          cvnodecollection exch  % convert sources to nodecollection
          4 2 roll              % bring sources and targets to bottom
          Connect_g_g_D_D
      } bind addtotrie


      % Variant: sources targets weight delay syn_model Connect
      % Connect nodes from two sets of node IDs using the default rule and
      % the given weight, delay and synapse model
	[node_idlisttype node_idlisttype /doubletype /doubletype /literaltype] {
          mark 4 1 roll         % put a mark before weight and delay
          /weight 4 1 roll      % add a label for the weight
          /delay 3 1 roll       % add a label for the delay
        /synapse_model 2 1 roll  % add a label for the synapse model
          >>                    % create the syn_spec dictionary
          /syn_spec :Connect_complete_dict    % fill in missing defaults
          /Connect /conn_spec GetOption exch  % use default conn_spec
          4 2 roll              % bring sources and targets to top
          cvnodecollection exch  % convert targets to nodecollection
          cvnodecollection exch  % convert sources to nodecollection
          4 2 roll              % bring sources and targets to bottom
          Connect_g_g_D_D
      } bind addtotrie

      % Variant: sources targets conn_rule Connect
      % Connect nodes from two sets of node IDs using the given rule and
      % default synapse model
      [node_idlisttype node_idlisttype /literaltype] {
	  mark exch /rule exch >>  % create the conn_spec dictionary
	  /conn_spec :Connect_complete_dict  % fill in missing defaults
	  3 1 roll                 % bring sources and targets to top
	  cvnodecollection exch     % convert targets to nodecollection
	  cvnodecollection exch     % convert sources to nodecollection
	  3 2 roll                 % bring sources and targets to bottom
	  /Connect /syn_spec GetOption  % use default syn_spec
	  Connect_g_g_D_D
      } bind addtotrie

      % Variant: sources targets conn_spec Connect
      % Connect nodes from two sets of node IDs using the given connectivity
      % specification and default synapse model
      [node_idlisttype node_idlisttype /dictionarytype] {
	  /conn_spec :Connect_complete_dict  % fill in missing defaults
	  3 1 roll              % bring sources and targets to top
	  cvnodecollection exch  % convert targets to nodecollection
	  cvnodecollection exch  % convert sources to nodecollection
	  3 2 roll              % bring sources and targets to bottom
	  /Connect /syn_spec GetOption  % use default syn_spec
	  Connect_g_g_D_D
      } bind addtotrie

      % Variant: sources targets conn_rule syn_model Connect
      % Connect nodes from two sets of node IDs using the given rule and
      % synapse model
      [node_idlisttype node_idlisttype /literaltype /literaltype] {
    	  mark exch /synapse_model exch >>  % create the syn_spec dictionary
	  /syn_spec :Connect_complete_dict   % fill in missing defaults
	  exch                      % exchange syn_spec and conn_spec
	  mark exch /rule exch >>   % create the conn_spec dictionary
	  /conn_spec :Connect_complete_dict  % fill in missing defaults
	  exch                      % exchange syn_spec and conn_spec
	  4 2 roll                  % bring sources and targets to top
	  cvnodecollection exch      % convert targets to nodecollection
	  cvnodecollection exch      % convert sources to nodecollection
	  4 2 roll                  % bring sources and targets to bottom
	  Connect_g_g_D_D
      } bind addtotrie

      % Variant: sources targets conn_spec syn_model Connect
      % Connect nodes from two sets of node IDs using the given rule and
      % synapse specification
      [node_idlisttype node_idlisttype /literaltype /dictionarytype] {
	  /syn_spec :Connect_complete_dict   % fill in missing defaults
	  exch                     % exchange syn_spec and conn_spec
	  mark exch /rule exch >>  % create the conn_spec dictionary
	  /conn_spec :Connect_complete_dict  % fill in missing defaults
	  exch                     % exchange syn_spec and conn_spec
	  4 2 roll                 % bring sources and targets to top
	  cvnodecollection exch     % convert targets to nodecollection
	  cvnodecollection exch     % convert sources to nodecollection
	  4 2 roll                 % bring sources and targets to bottom
	  Connect_g_g_D_D
      } bind addtotrie

      % Variant: sources targets conn_rule syn_spec Connect
      % Connect nodes from two sets of node IDs using the given connectivity
      % specification and synapse model
      [node_idlisttype node_idlisttype /dictionarytype /literaltype] {
    	  mark exch /synapse_model exch >>  % create the syn_spec dictionary
	  /syn_spec :Connect_complete_dict   % fill in missing defaults
	  exch                      % exchange syn_spec and conn_spec
	  /conn_spec :Connect_complete_dict  % fill in missing defaults
	  exch                      % exchange syn_spec and conn_spec
	  4 2 roll                  % bring sources and targets to top
	  cvnodecollection exch      % convert targets to nodecollection
	  cvnodecollection exch      % convert sources to nodecollection
	  4 2 roll                  % bring sources and targets to bottom
	  Connect_g_g_D_D
      } bind addtotrie

      % Variant: sources targets conn_spec syn_spec Connect
      % Connect nodes from two sets of node IDs using the given connectivity
      % and synapse specifications
      [node_idlisttype node_idlisttype /dictionarytype /dictionarytype] {
        /syn_spec :Connect_complete_dict   % fill in missing defaults
        exch                   % exchange syn_spec and conn_spec
        /conn_spec :Connect_complete_dict  % fill in missing defaults
        exch                   % exchange syn_spec and conn_spec
        4 2 roll               % bring sources and targets to top
        cvnodecollection exch  % convert targets to nodecollection
        cvnodecollection exch  % convert sources to nodecollection
        4 2 roll               % bring sources and targets to bottom
        Connect_g_g_D_D
      } bind addtotrie

      % Variant: sources targets conn_spec syn_vector Connect
      % Connect nodes from two sets of NodeCollections using the given connectivity specification
      % and a list of synapse specifications
      [node_idlisttype node_idlisttype /dictionarytype /arraytype] {
        /test_syn_specs Set
        test_syn_specs
        {
          /syn_spec :Connect_complete_dict
          pop
        } forall
        test_syn_specs
        Connect_g_g_D_a
      } bind addtotrie

  } forall

def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


/** @BeginDocumentation
   Name: GetConnections - Retrieve connections between nodes

   Synopsis:
   << /source [snode_id1 snode_id2 ...]
      /target [tnode_id1 tnode_id2 ...]
      /synapse_model /smodel
      /synapse_label label      >> GetConnections -> [ conn1 conn2 ... ]

   Parameters:
   A dictionary that may contain the following fields (all are optional):
   /source  - array with node IDs of presynaptic nodes whose connections are sought.
              If not given, all neurons are searched as sources.
   /target  - array with node IDs of postsynaptic nodes whose connections are sought.
              If not given, all neurons are searched as targets.
   /synapse_model - literal specifying synapse model
                    If not given, connections of all synapse models are returned.
   /synapse_label - integer specifying synapse label
                    If not given, connections of all synapse labels are returned.

   Description:
   1. If called with an empty dictionary, GetConnections returns all connections of the
      network, as a list of arrays (IntVectorDatum), one array per connection.
   2. Each array (connection object) has the following elements:
      [source-node_id target-node_id target-thread synapse-model-id port]
      where synapse-model-id corresponds to the position of the model in the list
      of models available from the /synapse_models property of the kernel status dictionary.
   3. The optional dictionary elements /source and /target can be used to filter
      for specific pre- and postsynaptic neurons, respectively.
   4. The optional parameter /synapse_model can be used to filter for a specific synapse model.
   5. The optional parameter /synapse_label can be used to filter for a specific synapse label.
   6. In a parallel simulation, GetConnections only returns connections with *targets*
      on the MPI process executing the function.

   Remarks:
   1. The /synapse_label property can only be assigned to synapse models with names ending
      with '_lbl'. All other synapses have the default synapse_label UNLABELED_CONNECTION (-1).
   2. The "port" enumerates connections per source, thread and synapse model. It is
      mainly important for NEST internally.
   3. In OpenMP mode, GetConnections works thread-parallel for better performance.
   4. Connection objects can be converted to SLI lists with cva.
   5. Connection objects can be passed to SetStatus, and GetStatus
*/
/GetConnections [/dictionarytype]
{
  /pdict Set
  [ /source /target ]
  {
    /key Set
    pdict key known
    {
      pdict key get
      NodeCollectionQ exch ; not
      {
	      key cvs ( argument must be NodeCollection) join M_ERROR message
	      /GetConnections /ArgumentError raiseerror
      }
      if
    }
    if
  }
  forall
  pdict GetConnections_D
}
def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/** @BeginDocumentation
   Name: elementstates - dictionary with symbolic element state tag

   Description:
   Each element has a state which can be accessed via it's status dictionary.
   The state is defined as a superposition of the following values:
   /valid       1
   /busy        2
   /updated     4
   /suspended   8
   /frozen     16
   /buffers_initialized 32
   /err        64
   valid      - the default state of an element.
   busy       - indicates that this element needs more than one cycle to
                update and is not yet fully updated.
   updated    - indicates, that the element was updated in the current cycle.
                once the update cycle is completed, all updated flags are
		changed to valid.
		This flag shoulds only be set if the update cycle was
		interrupted or suspended.
   suspended  - indicates, that the update of this element was suspended. The
                next call to simulate will continue with this element.
   frozen     - if this state is set, the update cycle skips this element. In
                effect, the element keeps its state intact as if it was "frozen".
		This is the only state which can directly be set by the user.
   buffers_initialized - the buffers of the node have been initialized
   err        - some unspecified error condition has occurred.

   Examples: elementstates info

   Availability: NEST
*/

/elementstates
<<
  /valid       1
  /busy        2
  /updated     4
  /suspended   8
  /frozen     16
  /buffers_initialized 32
  /err        64
>> def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/** @BeginDocumentation
   Name: unit_conversion - Conversion factors for SI units.

   Description:
   Some SLI functions and tools expect numerical arguments which carry SI units.
   function/tool        expected unit
   ----------------------------------
   Simulate             ms
   current generators   pA
   voltmeters           mV
   ac_generator         Hz

   As SLI does not know any unit conversion scheme, numerical values
   need to be specified in the appropriate units. However, it improves
   readability, if a hint to the unit is specified in the program code,
   such as "333 pA", instead of just "333".
   Furthermore, it may be convenient to have other units converted to the
   ones expected by the routines. (For example, "ms" converts from milliseconds
   to timesteps, taking into account the current network resolution, see
   example below.)

   The following conversion factors are known (developers: please add others in
   nest-init.sli as required):
   ms, pA, mV, Hz, spikes

   Examples:
   The following call always simulates 1000 ms of network time,

   1000 ms Simulate

   Author: (unknown), documented by Ruediger Kupper, 18-jul-2003

   Availability: This is just a description. unit_conversion is no SLI command.
   SeeAlso: Hz, ms, pA, mV, spikes, cvd, cvi
*/

%% Some auxiliary definitions, just for readibility

/** @BeginDocumentation
   Name: ms - Specification in ms (for readability)
   SeeAlso: unit_conversion, ms2hms
*/
/ms /cvd load def

/** @BeginDocumentation
   Name: s - Specification in s (for readability)
   SeeAlso: unit_conversion, ms2hms
*/
/s {1000.0 mul} bind def

/** @BeginDocumentation
   Name: pA - Specification in pA (for readability)
   SeeAlso: unit_conversion
*/
/pA /cvd load def

/** @BeginDocumentation
   Name: nS - Specification in nS (for readability)
   SeeAlso: unit_conversion
*/
/nS /cvd load def
/** @BeginDocumentation
   Name: pF - Specification in pF (for readability)
   SeeAlso: unit_conversion
*/
/pF /cvd load def

/** @BeginDocumentation
   Name: mV - Specification in mV (for readability)
   SeeAlso: unit_conversion
*/
/mV /cvd load def

/** @BeginDocumentation
   Name: Hz - Specification in Hz (for readability)
   SeeAlso: unit_conversion
*/
/Hz /cvd load def

/** @BeginDocumentation
   Name: spikes - Specification in spikes (for readability)
   SeeAlso: unit_conversion
*/
/spikes /cvi load def

/double /cvd load def

/int    /cvi load def


/** @BeginDocumentation
   Name: SubsetQ - Test if one dictionary is a subset of another

   Synopsis:
   dict1 dict2 SubsetQ -> bool

   Parameters:
   dict1 - dictionary
   dict2 - dictionary

   Description:
   The functions returns true, if all entries of dict2 are present in dict1
   with the same values.

   Examples:
   << /a 1 /b 2 /c 2 >> << /c 2 >> SubsetQ -> true
*/
/SubsetQ
[/dictionarytype /dictionarytype]
{
  << >> begin
  cva 2 Partition
  /properties Set
  /object Set

  true
  properties
  {
    arrayload ;
    /val Set
    cvlit /key Set
    object dup key known
    {
      key get
      val eq and
    }
    {
     pop pop false exit
    } ifelse
  } forall
  end
} bind def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/** @BeginDocumentation
   Name: ShowStatus - Show the status dictionary of a network node.

   Synopsis:
   node_id ShowStatus -> -

   Description:
   ShowStatus retrieves the status dictionary of the specified node
   and displays it, using info.
   ShowStatus is equivalent to the sequence "GetStatus info"

   SeeAlso: GetStatus, info
*/

/ShowStatus
{
  GetStatus info
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/** @BeginDocumentation
   Name: TimeCommunication - returns average time taken for MPI_Allgather over n calls with m bytes
   Synopsis:
   n m [bool] TimeCommunication -> time
   Availability: NEST 2.0
   Author: Abigail Morrison
   FirstVersion: August 2009
   Description:
   The function allows a user to test how much time a call the Allgather costs
   If boolean third argument is passed and true, time offgrid spike communication.
   SeeAlso: TimeCommunicationOffgrid
 */
/TimeCommunication trie
[/integertype /integertype /booltype] /TimeCommunication_i_i_b load addtotrie
[/integertype /integertype] { false TimeCommunication_i_i_b } bind addtotrie
def

/TimeCommunicationv trie
[/integertype /integertype] /TimeCommunicationv_i_i load addtotrie
def

  /** @BeginDocumentation
     Name: TimeCommunicationOffgrid - returns average time taken for MPI_Allgather over n calls with m bytes when communication offgrid spikes
     Synopsis:
     n m [bool] TimeCommunication -> time
     Availability: NEST 2.0
     Author: Abigail Morrison
     FirstVersion: August 2009
     Description:
     The function allows a user to test how much time a call the Allgather costs
     SeeAlso: TimeCommunication
   */
/TimeCommunicationOffgrid trie
[/integertype /integertype] { true TimeCommunication_i_i_b } bind addtotrie

def
  /** @BeginDocumentation
     Name: TimeCommunicationAlltoall - returns average time taken for MPI_Alltoall over n calls with m bytes
     Synopsis:
     n m TimeCommunicationAlltoall -> time
     Availability: 10kproject (>r11254)
     Author: Jakob Jordan (modified TimeCommunication)
     FirstVersion: June 2014
     Description:
     The function allows a user to test how much time a call to MPI_Alltoall costs
     SeeAlso: TimeCommunication
   */
/TimeCommunicationAlltoall trie
[/integertype /integertype] /TimeCommunicationAlltoall_i_i load addtotrie
def

  /** @BeginDocumentation
     Name: TimeCommunicationAlltoallv - returns average time taken for MPI_Alltoallv over n calls with m bytes
     Synopsis:
     n m TimeCommunicationAlltoallv -> time
     Availability: 10kproject (>r11300)
     Author: Jakob Jordan (modified TimeCommunication)
     FirstVersion: July 2014
     Description:
     The function allows a user to test how much time a call to MPI_Alltoallv costs
     SeeAlso: TimeCommunication
   */
/TimeCommunicationAlltoallv trie
[/integertype /integertype] /TimeCommunicationAlltoallv_i_i load addtotrie
def

/cva [/connectiontype] /cva_C load def

/abort
{
  statusdict /exitcodes get /userabort get
  statusdict /is_mpi get { MPI_Abort }{ quit_i } ifelse
} bind def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     Functions relating to spatial positions
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/ConnectLayers [/nodecollectiontype /nodecollectiontype /dictionarytype]
  /ConnectLayers_g_g_D load
def

/CreateLayerParams [/dictionarytype /dictionarytype]
  /CreateLayer_D_D load
def

/CreateLayer [/dictionarytype]
{
  << >> CreateLayerParams
} def

/GetPosition [/nodecollectiontype]
  /GetPosition_g load
def

% nc_from, nc_to
/Displacement [/nodecollectiontype /nodecollectiontype]
  /Displacement_g_g load
def

/Displacement [/arraytype /nodecollectiontype]
  /Displacement_a_g load
def

% nc_from, nc_to
/Distance [/nodecollectiontype /nodecollectiontype]
  /Distance_g_g load
def

/Distance [/arraytype /nodecollectiontype]
    /Distance_a_g load
def

/Distance [/arraytype]
    /Distance_a load
def

/GetLayerStatus [/nodecollectiontype]
    /GetLayerStatus_g load
def

/DumpLayerNodes [/ostreamtype /nodecollectiontype]
  { DumpLayerNodes_os_g } bind
def

/DumpLayerConnections [/ostreamtype /nodecollectiontype /nodecollectiontype /literaltype]
  /DumpLayerConnections_os_g_g_l load
def

/CreateMask [/dictionarytype]
  /CreateMask_D load
def

/Inside [/arraytype /masktype]
  /Inside_a_M load
def

/Inside [/arraytype /dictionarytype]
  { CreateMask Inside_M_a } bind
def

/and [/masktype /masktype]
  /and_M_M load
def

/or [/masktype /masktype]
  /or_M_M load
def

/sub [/masktype /masktype]
  /sub_M_M load
def

/cvdict [/masktype]
  /cvdict_M load
def

/get [/masktype /literaltype] {exch cvdict_M exch get} def
/get [/masktype /arraytype] {exch cvdict_M exch get} def

/SelectNodesByMask [/nodecollectiontype /arraytype /masktype]
  /SelectNodesByMask_g_a_M load
def


% Install modules in environment variable NEST_MODULES. Modules have
% to be separated by colon.
(NEST_MODULES) getenv { (:) breakup { Install } forall } if
