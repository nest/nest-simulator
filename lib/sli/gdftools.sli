/*
 *  gdftools.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

%% GDFTools Library initialization
%% this file is currently not automatically loaded.
systemdict begin

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Base Class
%% gdffilter CreateGDFBase -> gdffilter(dict)
/CreateGDFBase
{
 %% gdffilter
  << >> dup begin
 %% gdffilter dict
  exch
 %% dict gdffilter
  /gdffilter Set

 %% - getevent -> event true
 %%            -> false
  /getevent 
  {
    {
      %% Call the filter's getevent
      %% Method until filter returns true or
      %% the input filter is exhausted.
      %% filter returns false to indicate that
      %% a new event is requested. On success,
      %% it returns the filtered event and true
 
      gdffilter /getevent call_
      {
       %% event
        filter  {true exit } if        
      }
      {
       false exit
      } ifelse
    } loop
  } bind def

  %% eventarray mapfilter -> eventarray'
  /mapfilter
  {
    {
     filter
     pop_
    } Map
  } bind def

  %% - getallevents -> eventarray 
  /getallevents
  {
    gdffilter 
    begin
     getallevents
    end
    mapfilter
  } bind def

  %% getallevents -> eventarray 
 /getallevents_slim
 {
  gdffilter
  begin
  mark 
  {
    getevent
    not_b {exit} if
  } loop
  counttomark arraystore exch_ pop_
  end
 } bind def

  end
} bind def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Used for terminating a GDF filter cascade
%% e.g. writing to streams

/CreateGDFBackend
{
 %% gdffilter
  << >> dup begin
 %% gdffilter dict
  exch
 %% dict gdffilter
  /gdffilter Set

 /getevent
 {
   false
 } def

 /getallevents
 {
   []
 } def

%% event filter -> - 
  /filter
  {
    pop_
  } bind def


  %% eventarray mapfilter -> -
  /mapfilter
  {
    {
     filter
    } forall_a   
  } bind def

  /getallevents_slim
  {
   []
  } def


  %% putevent -> true/false
  /putevent
  {
    gdffilter 
    begin 
      getevent 
    end
    filter
  } bind def

  %% putallevents -> - 
  /putallevents
  {
    gdffilter
    begin
      getallevents
    end
    mapfilter
  } bind def  

  end
} bind def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% This filter writes data in form of the Matlab CellArray format.
%% - Initialize with a gdffilter and an continuous List of neuronIDs,
%%   ranging from 1...N
%% - The supplied filter must ensure that all neuron ids
%%   are within the supplied range.
%% - Method putallevents prepares the events for output
%% - Method ostream  writemap prints the data to the supplied file.
%%
%% gdffilter idList
/CreateCDFFilter
{
  exch
  CreateGDFBackend
  dup begin
  exch
  {
    pop_ []
  } Map
  /eventmap Set_
  

  % event filter -> -
  /filter
  {
     dup 1 get_a 1 sub_ii
     %% [tr id t] id
     exch_ 1 1 erase_a
     %% id [tr t]
     eventmap 2 index get_a
     %% id [tr t] array
     exch_ append_a
     eventmap 3 1 roll
     put_a /eventmap Set_
  } bind def

  % - getmap -> cellarray
  /getmap
  {
    eventmap
  } def


  %% ostream array -> ostream
  /:writearray
  {
    exch_ (array ) <-
    1 index Dimensions
    dup_ length_a
    %% array ostream [dim] rank
    4 -1 roll
    %% ostream [dim] rank array
    exch_
    { Flatten } 
    repeat
    %% ostream [dim] array
    3 1 roll
    %% array ostream [dim]
    exch_
    %% array [dim] ostream
    1 index length_a <- ( ) <-
    exch_ Reverse
    { <- ( ) <-} forall_a 
    (\n) <-
    exch_
    { <- ( ) <-}
    forall_a
    (\n) <-
  } bind def


  %% ostream writemap -> ostream
  /writemap
  {
    (cell ) <-
    eventmap length <- (\n) <-
    eventmap
    {
      :writearray
    } forall_a
  } bind def

  end
} bind def
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Triple format Backend
%%
%% Write data in the tuple-data format:
%% trial nid  time
%%
/CreateWriteTDFFile
{
  exch
  CreateGDFBackend
  dup begin
  exch 
  /outfile Set
  
  % event filter -> -
  /filter
  {
    outfile exch_
    {
     <- (\t) <-
    } forall_a
    endl ;
  } bind def

  end
} bind def
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TDFArray
%%  Wraps a Triple Array in a GDF filter. This is useful
%%  to re-insert data into a filter cascade, e.g. for writing
%%  to a file with WriteGDFFile
%%
%% triplearray  CreateTDFArray -> TDFArray(dict)

/CreateTDFArray
{
  CreateGDFBase
  dup begin
  
  /:position 0 def

  /getevent
  {
    gdffilter
    size_a
    :position gt_ii
    {
      :position get_a true
      /:position ::position 1 add_ii def_
    }
    { false }
    ifelse
  } bind def

  %% getallevents_slim -> eventarray 
 /getallevents_slim
 {
   gdffilter 0 :position  erase_a
   /:position gdffilter length def_
 } bind def

 /getallevents /getallevents_slim load def

 /reset
 {
   /:position 0 def_
 } bind def
 end
} bind def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% file TriggerID Pre Post NeuronIDs CreateGDFFile -> GDFFile(dict)
/CreateGDFFile
{
  CreateGDFReader CreateGDFBase
  dup begin
  /getevent
  {
    gdffilter getevent_gdf
  } bind def

  %% getallevents_slim -> eventarray 
 /getallevents_slim
 {
  mark 
  {
    gdffilter getevent_gdf
    not_b {exit} if
  } loop
  counttomark arraystore exch_ pop_
 } bind def

 /getallevents /getallevents_slim load def

 /settrials 
 {
    gdffilter exch_ SetGDFReaderTrials
 } bind def

 /gettrials
 {
   gdffilter gettrials_reader
 } bind def

 end
} bind def



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Maps the Neurons in neuronlist to the range of IDs
%% 1..length(neuronlist)
%%
%% gdffilter neuronlist CreateNeuronMapper -> NeuronMapper(dict)
/CreateNeuronMapper
{
 %% gdffilter neuronlist 
  exch
 %% neuronlist gdffilter
  CreateGDFBase dup begin
 %% neuronlist dict
  exch 
 %% dict neuronlist
  /neuronmap integermap def
 %% dict neuronlist
  neuronmap exch
 %% dict neuronmap neuronlist
  {  
 %% neuronmap neuronid neuronidx
    1 add_ii
    put_imap
 %% dict gdffilter neuronmap
  } forallindexed_a
  pop
%% dict

  %% Map an arbitrary array of Neuron IDs 
  %% to an array of mapped IDs
  %% array MapArray -> array
  /MapArray
  {
    {
      dup_ type
      /arraytype eq
      {
        MapArray
      }
      {
        neuronmap exch_ get_imap
        not_b {/NeuronMapper::MapArray /UnexpectedNeuronID raiseerror } if
      } ifelse
    } Map
  } bind def

  %% event filter -> event true
  %%              -> false
  /filter
  {
  %% event
   dup_ 1 get_a
  %% event nid
   neuronmap 
   exch_ get_imap
  %% event mappednid true
  %%      or
  %% event false
   not_b
   {
    /NeuronMapper::apply /UnexpectedNeuronID raiseerror
   } if

  %% event mappednid
   1 exch_ put_a
   true
  } bind def

  end
} bind def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% gdffilter grouplist CreateGUSTMapper -> GUSTMapper(dict)
%%
%% An event is defined as [line, panel, time]
%% For a standard Synfire DotDisplay (GUST), we need to re-format
%% events of the SUMT form [trial, nID, time] to [ngid, gid, time]
%% ngid: Neuron index within the Group gid
%% gid : Number of the group
%% Note that the trial information of the SUMT form gets lost.

/CreateGUSTMapper
{
 %% gdffilter grouplist 
  exch
 %% grouplist gdffilter
  CreateGDFBase dup begin
 %% grouplist dict
  exch
  /grouplist Set

  %% event filter -> event true
  %%              -> false
  /filter
  {
   %% event
    dup_ 1 get_a
   %% event nid
    grouplist
    exch_ 1 sub_ii get_a
   %% event [nid gid]
    exch_ 2 get_a
    append_a
    true
  } bind def

  end
} bind def
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% gdffilter grouplist CreateGUMTMapper -> GUMTMapper(dict)
%%
%% An event is defined as [line, panel, time (, colour)]
%% For a standard Synfire DotDisplay (GUST), we need to re-format
%% events of the SUMT form [trial, nID, time] to [ngid, gid, time, trial]
%% ngid: Neuron index within the Group gid
%% gid : Number of the group
%% Note that the trial information of the SUMT form moves from
%% the head to the tail of the list.

/CreateGUMTMapper
{
 %% gdffilter grouplist 
  exch
 %% grouplist gdffilter
  CreateGDFBase dup begin
 %% grouplist dict
  exch
  /grouplist Set

  %% event filter -> event true
  %%              -> false
  /filter
  {
   %% event
    dup_ 1 get_a
   %% event nid
    grouplist
    exch_ 1 sub_ii get_a
   %% event [nid gid]
    1 index 2 get_a
    append_a
   %% event [nid gid time]
    exch_ 0 get_a
    append_a
   %% [nid gid time trial]
    true
  } bind def

  end
} bind def
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% gdffilter CreateMUSTMapper -> MUSTMapper(dict)
/CreateMUSTMapper
{
 %% gdffilter
  CreateGDFBase dup begin

  %% event filter -> event true
  %%              -> false
  /filter
  {
   %% event
    dup_ 0 get_a
    exch_
    dup_ 1 get_a
    0 exch_ put_a
    exch_ 1 exch_ put_a
    true
  } bind def

  end
} bind def
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% nl = [1 2 3 4 5 6 7 8]
%% gl = [ [1 2 3 4] [5 6 7 8] ]
%% --> [ [1 1] [2 1] [3 1] [4 1] [1 2] [2 2] [3 2] [4 2]]
%% nl = [1 2 3 4 5 6 7 8]
%% gl = [ [5 6 7 8]  [1 2 3 4] ]
%% --> [ [1 2] [2 2] [3 2] [4 2] [1 1] [2 1] [3 1] [4 1]]
%% n gl
%% Neuron indices range from 1..n
%% Group list must only use indices in that
%% range.
%% Each neuron should only appear once in the group list!

/GUSTMap
{
  exch_ 1 arraystore Range exch_
  {
    %% nl grarray idx
    1 add_ii %% Remapping starts from 1
    exch_ %% nl gidx grarray
    {
       1 add_ii %% Remapping starts from 1
       %% nl gidx nid nidx
       2 index
       %% nl gidx nid nidx gidx
       2 arraystore
       %% nl gidx nid [nidx gidx]
       exch_ 1 sub_ii exch_
       %% nl gidx nid [nidx gidx]
       4 -1 roll
       %% gidx nid [nidx gidx] nl
       3 1 roll
       %% gidx nl nid [nidx gidx]
       put_a
       %% gidx nl
       exch_
       %% nl gidx 
    }  forallindexed_a
    %% nl gidx
    pop_
    %% nl
  } forallindexed_a  
} bind def

%% gdffilter(dict)getallevents -> eventarray
/getallevents
{
  begin
   getallevents
  end
} bind def

%% gdffilter(dict) -> event true
%%                 -> false
/getevent_dict
{
  begin
   getevent
  end
} bind def
  
%% gdffilter getevent -> gdffilter event true
%%                    -> false
/getevent trie
 [/dictionarytype] /getevent_dict   load addtotrie
 [/gdfreadertype]  /getevent_gdf load addtotrie
def

end

